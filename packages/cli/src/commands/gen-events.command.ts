import * as fs from "fs";
import * as path from "path";
import { ICommand } from "./base.command";
import { Parser } from "@asyncapi/parser";
import { TypeScriptGenerator } from "@asyncapi/modelina";

export class GenEventsCommand implements ICommand {
  async execute() {
    const contractsDir = path.resolve(
      "node_modules/@coolcinema/contracts/events",
    );
    const outDir = path.resolve("src/_gen/events");

    if (!fs.existsSync(contractsDir)) {
      console.log("No events contracts found.");
      return;
    }

    const parser = new Parser();
    const generator = new TypeScriptGenerator({
      modelType: "interface",
      enumType: "union",
    });

    const files = fs
      .readdirSync(contractsDir)
      .filter((f) => f.endsWith(".yaml"));

    for (const file of files) {
      const content = fs.readFileSync(path.join(contractsDir, file), "utf8");

      const { document, diagnostics } = await parser.parse(content);

      if (!document) {
        console.error(`Failed to parse ${file}`, diagnostics);
        continue;
      }

      const serviceName = path.basename(file, ".yaml");

      const models = await generator.generate(document);

      let tsCode = `/**
 * Auto-generated by CoolCinema CLI
 * Service: ${serviceName}
 * Spec: AsyncAPI v3
 */

`;

      for (const model of models) {
        tsCode += model.result + "\n";
      }

      tsCode += this.generateDefinitions(document);

      const outFile = path.join(outDir, `${serviceName}.ts`);
      fs.mkdirSync(path.dirname(outFile), { recursive: true });
      fs.writeFileSync(outFile, tsCode);

      console.log(`âœ… Generated events for ${serviceName}`);
    }
  }

  private generateDefinitions(doc: any): string {
    const channels = doc.channels();
    const operations = doc.operations();

    const defs: any = {
      channels: {},
      operations: {},
    };

    channels.forEach((channel: any) => {
      defs.channels[channel.id()] = {
        address: channel.address(),
      };
    });

    operations.forEach((op: any) => {
      const action = op.action();
      const channel = op.channels()[0];

      defs.operations[op.id()] = {
        action: action,
        channelId: channel ? channel.id() : null,
        messages: op.messages().map((m: any) => m.name() || m.id()),
      };
    });

    const pascalName = this.toPascal(path.basename(doc.info().title()));

    return `\nexport const ${pascalName}Defs = ${JSON.stringify(defs, null, 2)} as const;`;
  }

  private toPascal(str: string) {
    return str
      .replace(/(?:^\w|[A-Z]|\b\w)/g, (w) => w.toUpperCase())
      .replace(/[\s\-_]+/g, "");
  }
}
